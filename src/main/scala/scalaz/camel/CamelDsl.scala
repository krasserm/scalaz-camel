/*
 * Copyright 2010-2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package scalaz.camel

import java.util.concurrent.CountDownLatch

import org.apache.camel.{Exchange, AsyncCallback, AsyncProcessor}

import scalaz._

/**
 * @author Martin Krasser
 *
 * @see scalaz.camel.Camel
 */
trait CamelDsl extends CamelConv {
  import concurrent.Promise
  import concurrent.Strategy
  import Scalaz._
  import Message._

  // ------------------------------------------
  //  EIPs
  // ------------------------------------------

  /**
   * Concurrency strategy for distributing messages to destinations with the multicast EIP.
   */
  protected def multicastStrategy: Strategy

  /**
   * The content-based router EIP.
   */
  def choose(f: PartialFunction[Message, MessageValidationResponderKleisli]): MessageValidationResponderKleisli =
    kleisli[Responder, MessageValidation, MessageValidation](
      (mv: MessageValidation) => mv match {
        case Failure(e) =>  new MessageValidationResponder(Failure(e), null)
        case Success(m) =>  new MessageValidationResponder(Success(m), messageProcessor(f(m)))
      }
    )

  /**
   * The recipient-list EIP. It applies the concurrency strategy returned by
   * <code>multicastStrategy</code> to distribute messages to their destinations.
   */
  def multicast(destinations: MessageValidationResponderKleisli*)(aggregator: MessageAggregator): MessageValidationResponderKleisli = {
    val mcf = multicastFunction(destinations.toList, aggregator)
    kleisli[Responder, MessageValidation, MessageValidation](
      (mv: MessageValidation) => mv match {
        case Failure(e) =>  new MessageValidationResponder(Failure(e), null)
        case Success(m) =>  new MessageValidationResponder(Success(m), mcf)
      }
    )
  }

  private def multicastFunction(destinations: List[MessageValidationResponderKleisli], aggregator: MessageAggregator): MessageProcessor =
    (m: Message, k: MessageValidation => Unit) => {
      val ctr = new java.util.concurrent.atomic.AtomicInteger(destinations.size)
      val mva = Array.fill[MessageValidation](destinations.size)(null)

      // collects destinations.size results and combines
      // them (once they're available) using aggregator
      val cont = (mv: MessageValidation, pos: Int) => {
        mva.synchronized(mva(pos) = mv)
        if (ctr.decrementAndGet == 0) {
          val mvl = mva.synchronized(mva.toList)
          k(mvl.tail.foldLeft(mvl.head) {(z, m) => m <*> z âˆ˜ aggregator.curried})
        }
      }

      // mutlicast using concurrency as provided by multicastStrategy
      destinations.foldLeft(0) { (pos, d) => {
          multicastStrategy.apply {
            d apply m.success respond { mv =>  cont(mv, pos) }
          }
          pos + 1
        }
      }
    }

  /** Semigroup to 'append' exceptions. Returns the first exception and ignores the second */
  implicit def ExceptionSemigroup: Semigroup[Exception] = semigroup((e1, e2) => e1)

  // ------------------------------------------
  //  Access to message processing results
  // ------------------------------------------

  /**
   * Provides convenient access to (asynchronous) message validation responses
   * generated by responder r. Hides continuation-passing style (CPS) usage of
   * responder r.
   *
   * @see Camel.responderToResponseAccess
   */
  class ValidationResponseAccess(r: Responder[MessageValidation]) {
    /** Obtain response from responder r (blocking) */
    def response: MessageValidation = responsePromise(Strategy.Sequential).get

    /** Obtain response promise from responder r */
    def responsePromise(implicit s: Strategy): Promise[MessageValidation] = {
      val queue = new java.util.concurrent.ArrayBlockingQueue[MessageValidation](2)
      r respond { mv => queue.put(mv) }
      promise(queue.take)
    }
  }

  /**
   * Provides convenient access to (asynchronous) message validation responses
   * generated by an application of responder Kleisli p (e.g. a Kleisli route)
   * to a message m. Hides continuation-passing style (CPS) usage of responder
   * Kleisli p.
   *
   * @see responderKleisliToResponseAccessKleisli
   */
  class ValidationResponseAccessKleisli(p: MessageValidationResponderKleisli) {
    /** Obtain response from responder Kleisli p for message m (blocking) */
    def responseFor(m: Message) = responsePromiseFor(m)(Strategy.Sequential).get

    /** Obtain response promise from responder Kleisli p for message m */
    def responsePromiseFor(m: Message)(implicit s: Strategy) =
      new ValidationResponseAccess(p apply m.success).responsePromise
  }

  // ------------------------------------------
  //  Route initiation and endpoints
  // ------------------------------------------

  /** Creates an endpoint producer */
  def to(uri: String)(implicit em: EndpointMgnt) = messageProcessor(uri, em)

  /** Defines the starting point of a route from the given endpoint */
  def from(uri: String)(implicit em: EndpointMgnt, cm: ContextMgnt) = new MainRouteDefinition(uri, em, cm)

  /** Represents the starting point of a route from an endpoint defined by <code>uri</code> */
  class MainRouteDefinition(uri: String, em: EndpointMgnt, cm: ContextMgnt) {
    /** Connects a route to the endpoint consumer */
    def route(r: MessageValidationResponderKleisli): ErrorRouteDefinition = {
      val processor = new RouteProcessor(r, cm) with ErrorRouteDefinition
      val consumer = em.createConsumer(uri, processor)
      processor
    }
  }

  /** Respresents the starting point of error handling routes for given exception classes */
  trait ErrorRouteDefinition {
    import collection.mutable.Buffer

    case class ErrorHandler(c: Class[_ <: Exception], r: MessageValidationResponderKleisli)

    private[camel] val errorHandlers = Buffer[ErrorHandler]()
    private[camel] var errorClass: Class[_ <: Exception] = _

    /** Associates the error handling route r with the current exception class */
    def route(r: MessageValidationResponderKleisli) = {
      errorHandlers append ErrorHandler(errorClass, r)
      this
    }

    /** Sets the current exception class to which an error handling route should be associated */
    def onError[A <: Exception](c: Class[A]) = {
      errorClass = c
      this
    }
  }

  private class RouteProcessor(p: MessageValidationResponderKleisli, cm: ContextMgnt) extends AsyncProcessor { this: ErrorRouteDefinition =>
    def process(exchange: Exchange, callback: AsyncCallback) =
      route(exchange.getIn.toMessage.cache(cm), callback, p, errorHandlers.toList)

    def route(message: Message, callback: AsyncCallback, target: MessageValidationResponderKleisli, errorHandlers: List[ErrorHandler]): Boolean = {
      val exchange = message.exchange
      target apply message.success respond { rv: MessageValidation =>
        rv match {
          case Failure(e) => {
            for (me <- exchange) {
              me.setException(e)
              errorHandlers.find(_.c.isInstance(e)) match {
                case None                     => callback.done(false)
                case Some(ErrorHandler(_, r)) => {
                  me.setException(null)
                  // route original message to error handler
                  // with the exception set on message header
                  route(message.reset.setException(e), callback, r, Nil)
                }
              }
            }
          }
          case Success(m) => {
            for (me <- exchange; e <- m.exception) {
              me.setException(e)
            }
            for (me <- exchange) {
              me.getIn.fromMessage(m)
              me.getOut.fromMessage(m)
            }
            callback.done(false)
          }
        }
      }
      false
    }

    def process(exchange: Exchange) = {
      val latch = new CountDownLatch(1)
      process(exchange, new AsyncCallback() {
        def done(doneSync: Boolean) = {
          latch.countDown
        }
      })
      latch.await
    }
  }
}